#pragma once

#include <functional>
#include <string>
#include <unordered_map>
#include <vector>

#include "../bus/bus.hpp"

class CPU {
 public:
  std::vector<uint8_t> snakeCode = {
      0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06,
      0x60, 0xa9, 0x02, 0x85, 0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85,
      0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85, 0x14, 0xa9, 0x04, 0x85,
      0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
      0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20,
      0x8d, 0x06, 0x20, 0xc3, 0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20,
      0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9, 0x77, 0xf0, 0x0d, 0xc9,
      0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
      0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9,
      0x08, 0x24, 0x02, 0xd0, 0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01,
      0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02, 0x60, 0xa9, 0x02, 0x24,
      0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
      0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01,
      0xc5, 0x11, 0xd0, 0x07, 0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60,
      0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06, 0xb5, 0x11, 0xc5, 0x11,
      0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
      0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca,
      0x10, 0xf9, 0xa5, 0x02, 0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0,
      0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9, 0x20, 0x85, 0x10, 0x90,
      0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
      0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69,
      0x20, 0x85, 0x10, 0xb0, 0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11,
      0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29, 0x1f, 0xc9, 0x1f, 0xf0,
      0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
      0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10,
      0x60, 0xa6, 0xff, 0xea, 0xea, 0xca, 0xd0, 0xfb, 0x60,
  };

 public:
  CPU();
  ~CPU();

  uint8_t a = 0x00;
  uint8_t x = 0x00;
  uint8_t y = 0x00;
  uint8_t p = 0x24;
  uint16_t pc = 0x0000;
  uint8_t sp = 0xFD;

  Bus bus;
  void connectBus(Bus b);

  void load();
  void run();
  void runWithFunction(std::function<void()> fn);
  void reset();

  bool closed = false;

  // private:
  uint8_t read(uint16_t addr);
  void write(uint16_t addr, uint8_t d);

  // Since the NES uses Little-Endian addressing (I don't know why ????), have
  // helper functions for reading/writing 16 bit numbers correctly
  uint16_t readInt(uint16_t addr);

  void writeInt(uint16_t addr, uint16_t d);

  void setZeroFlag(uint8_t d);
  void setNegFlag(uint8_t d);

  void setRegA(uint8_t d);
  void addRegA(uint8_t d);

  void setCarryFlag();
  void clearCarryFlag();

  uint8_t pop();
  uint16_t popInt();
  void push(uint8_t d);
  void pushInt(uint16_t d);

  // Addressing Modes
  enum AddressingMode {
    imm,
    zp0,
    zpx,
    zpy,
    abs,
    abx,
    aby,
    idx,
    idy,
    xxx,
  };

  void compare(AddressingMode m, uint8_t code);

  uint16_t getAddressingMode(AddressingMode opcode);
  uint16_t getAddress(AddressingMode m, uint16_t addr);

  void branch(bool con);

  // opcodes
  void adc(AddressingMode m);
  void adn(AddressingMode m);  // and is a keyword in cpp, so adn = add
  void aslAccum();
  uint8_t asl(AddressingMode m);
  void bit(AddressingMode m);
  uint8_t dec(AddressingMode m);
  void dex();
  void dey();
  void eor(AddressingMode m);
  uint8_t inc(AddressingMode m);
  void inx();
  void iny();
  void lda(AddressingMode m);
  void ldx(AddressingMode m);
  void ldy(AddressingMode m);
  void lsrAccum();
  uint8_t lsr(AddressingMode m);
  void ora(AddressingMode m);
  void php();
  void pla();
  void plp();
  void rolAccum();
  uint8_t rol(AddressingMode m);
  void rorAccum();
  uint8_t ror(AddressingMode m);
  void sbc(AddressingMode m);
  void sta(AddressingMode m);
  void tax();

  struct Ins {
    uint8_t opcode;
    std::string name;
    int length;
    int cycles;
    AddressingMode mode;
  };

  std::unordered_map<uint8_t, Ins> opcodes;

  void nmiInterrupt();
};
